# Tree (트리) - 자료구조 (3단계)

> **"부모-자식 관계로 데이터를 계층적으로 연결하는 설계"**

지금까지 우리는 데이터가 일렬로 줄 서는 **선형(Linear) 구조**만 다뤘다.  
하지만 세상의 데이터가 다 한 줄로 서 있진 않다.

**"회사 조직도"** 를 떠올려보자. 대표 아래에 팀장이 있고, 팀장 아래에 팀원이 있다.  
**"컴퓨터 폴더 구조"** 도 마찬가지다. C드라이브 안에 폴더가 있고, 그 안에 또 폴더가 있다.

이렇게 **계층(Hierarchy)** 이 있거나, 데이터를 **반씩 쪼개며 빠르게 찾고 싶을 때** 등장하는 것이 **트리(Tree)** 다.  
(해시가 O(1)이라면, 트리는 **O(log N)** — 반씩 쪼개서 찾는 구조다.)


## ⚠️ 이 문서의 위치

이 문서는 **03_Structure 폴더**에 있다. 즉, **Tree는 3단계 "자료구조(논리적 설계)"** 에 해당한다.

| 단계 | 명칭 | 역할 | 이 문서에서 |
| :--- | :--- | :--- | :--- |
| **1~2단계 (ADT)** | SortedMap, SortedSet, Priority Queue | "정렬된 검색", "우선순위 추출" - 기능 명세 | [Map](../../02_ADT/Map.md), [Set](../../02_ADT/Set.md) |
| **3단계 (자료구조)** | **Tree (BST, Heap 등)** | "어떻게 저장할까?" - 논리적 설계 | **← 이 문서** |
| **4단계 (구현체)** | TreeMap, TreeSet, PriorityQueue | 실제 코드로 구현한 클래스 | - |


## Tree 란?

**트리(Tree)** 는 **노드(Node)들이 부모-자식 관계로 연결된 계층형 자료구조** 다.  
맨 꼭대기에 **루트(Root)** 가 있고, 아래로 가지를 뻗듯이 자식들이 연결된다. 순환(Cycle)이 없다는 게 핵심이다.

```
        [Root]
       /      \
    [자식1]  [자식2]
    /    \
 [손자1] [손자2]
```

* **핵심 원리:** 하나의 부모는 여러 자식을 가질 수 있지만, 자식은 부모가 하나뿐이다.
* **목표:** 계층 표현, 또는 검색을 평균 **O(log N)** 에 수행.
* **물리적 기반:** 주로 **연결(Linked)** 기반이지만, 특수한 경우(힙) **배열** 도 사용.


## 언제 트리를 선택하는가? (2단계 가치 판단의 결과)

> **"이 섹션은 트리가 2단계라는 뜻이 아니다."**  
> 2단계 가치 판단에서 **"ADT(1단계 기능)에 어떤 제약조건을 더하면 트리(3단계)를 선택하게 되는가?"** 를 설명하는 것이다.

### 예시 1: SortedMap ADT를 구현한다고 하자

**1단계 (ADT 기능 정의):**  
"Key로 Value를 저장하고 찾고 싶어." → Map ADT  
"근데 **Key가 정렬된 상태**로 유지됐으면 좋겠어." → **SortedMap** ADT

**2단계 (가치 판단 - 제약조건 추가):**  
"정렬 상태 유지 + 범위 검색도 빨라야 해."

| 방식 | 검색 속도 | 정렬 유지 | 범위 검색 |
| :--- | :--- | :--- | :--- |
| **HashTable** | O(1) | ❌ 불가 | ❌ 불가 |
| **Tree (BST)** | **O(log n)** | ✅ 자동 | ✅ 가능 |

**결론:** "정렬 + 범위 검색이 필요하다!" → **트리(3단계 자료구조)** 선택.

### 예시 2: Priority Queue ADT를 구현한다고 하자

**1단계 (ADT 기능 정의):**  
"우선순위가 가장 높은 것부터 꺼내고 싶어." → **Priority Queue** ADT

**2단계 (가치 판단 - 제약조건 추가):**  
"최대/최소값을 **O(1)**에 꺼내야 해."

**결론:** "최대/최소를 빠르게!" → **힙(Heap, 3.5단계)** 선택.

### 트리로 구현되는 ADT들

| ADT | 트리 기반 구현체 | 핵심 기능 |
| :--- | :--- | :--- |
| **SortedMap** | `TreeMap` | Key 정렬 + O(log N) 검색 + 범위 검색 |
| **SortedSet** | `TreeSet` | 정렬된 집합 + O(log N) 검색 |
| **Priority Queue** | `PriorityQueue` (힙) | 최대/최소값을 O(1)에 추출 |
| **File System** | 디렉토리 구조 | 계층적 파일 관리 |


## 3단계 : 설계도를 짠다 (Logical Design)

* **질문:** "트리를 어떤 규칙으로 만들 것인가?"
* **설계:** 일반 트리는 자식이 N명이라 관리가 복잡하다. **자식을 최대 2명으로 제한** 하는 **이진 트리(Binary Tree)** 를 기본 뼈대로 잡는다.

### 잠깐! 자식이 여러 명인 트리는 없나요?

있다! **다원 트리(Multi-way Tree)** 라고 부른다.

| 종류 | 설명 | 용도 |
| :--- | :--- | :--- |
| **B-Tree** | 한 노드에 여러 Key + 여러 자식 | 파일 시스템, DB |
| **B+Tree** | 데이터는 리프에만, 리프끼리 연결 | **DB 인덱스 (MySQL)** |
| **Trie** | 문자마다 자식이 분기 | 검색어 자동완성 |

이진 트리만 쓰면 트리가 너무 깊어져서 **디스크 I/O가 많아지는 문제** 가 생긴다.  
그래서 DB처럼 대용량 데이터를 다루는 곳에서는 한 노드에 여러 데이터를 꽉꽉 눌러 담는 **다원 트리** 를 쓴다.

> **상세 내용:** [AdvancedTree_Overview](./AdvancedTree_Overview.md) 문서의 "다중 트리 (Multi-way Tree)" 섹션 참조.

### 이진 트리의 종류 (모양에 따른 분류)

3단계에서 결정한 모양(Shape)에 따라 4단계 구현 방식과 성능이 갈린다.

| 종류 | 설명 | 특징 |
| :--- | :--- | :--- |
| **일반 이진 트리** | 자식이 최대 둘인 트리 | 별 특징 없음 |
| **완전 이진 트리** | 위→아래, 왼쪽→오른쪽으로 빈틈없이 채움 | **배열 구현의 필수 조건** |
| **포화 이진 트리** | 피라미드처럼 꽉 찬 트리 | 완전의 특수 케이스 |
| **편향 이진 트리** | 한쪽으로만 쭉 뻗음 | 사실상 연결 리스트, 성능 최악 |


## 3.5단계 : 고오급 설계도 (Specific Algorithm)

> **"단순 이진 트리에 '특수 목적'을 위한 알고리즘을 입힌다."**
> 여기서 우리가 아는 유명한 자료구조들이 탄생한다.

### A. 목적이 '검색(Search)' 인가? → BST

* **규칙:** **"나보다 작은 건 왼쪽, 큰 건 오른쪽으로 가라."**
* **결과:** **이진 탐색 트리 (Binary Search Tree, BST)**
* **효과:** 데이터를 찾을 때마다 탐색 범위가 절반으로 줄어든다 (O(log N)).

### B. 목적이 '우선순위(VIP) 추출' 인가? → Heap

* **규칙 1 (모양):** 무조건 **완전 이진 트리** 여야 한다. (배열에 넣기 위해)
* **규칙 2 (질서):** **부모는 자식보다 무조건 커야 한다.** (형제끼린 상관 X)
* **결과:** **힙 (Heap)**
* **효과:** 최댓값(루트)을 O(1)에 뽑을 수 있다.

> **고급 트리:** 레드-블랙 트리, AVL 트리, B-Tree 등은 [AdvancedTree_Overview](./AdvancedTree_Overview.md) 문서 참조.


## 4단계 : 물리적 구현 (Physical Implementation)

> **"이 설계도를 메모리에 어떻게 올릴까?"**
> 3단계와 3.5단계에서 결정한 모양에 따라 구현 방법이 나뉜다.

### 방법 1 : 연결 기반 (Linked) - `Node`

* **대상:** 일반 트리, **이진 탐색 트리(BST)**
* **이유:** 데이터가 들어올 때마다 자리를 잡아야 하므로, 유동적인 연결 방식이 유리하다.

```java
class Node {
    Data value;
    Node left;   // 왼쪽 자식 주소
    Node right;  // 오른쪽 자식 주소
}
```

### 방법 2 : 배열 기반 (Array) - `ArrayList`

* **대상:** **힙 (Heap)**
* **이유:** 힙은 **완전 이진 트리** 이므로 중간에 빈칸이 없다. 인덱스 공식으로 부모-자식을 찾는 게 훨씬 빠르다.

```java
// 인덱스 공식 (1번 인덱스 시작 기준)
Left Child  = Index * 2
Right Child = Index * 2 + 1
Parent      = Index / 2
```


## 4단계로의 연결 : 구현체들

3단계와 3.5단계에서 설계한 "트리"를 실제 언어로 구현한 것이 **구현체** 다.

| 언어 | 구현체 | 내부 설계 | 비고 |
| :--- | :--- | :--- | :--- |
| **Java** | `TreeMap` | 레드-블랙 트리 | 정렬된 Map |
| **Java** | `TreeSet` | 레드-블랙 트리 | 정렬된 Set |
| **Java** | `PriorityQueue` | 힙 (배열 기반) | 우선순위 큐 |
| **C++** | `std::map`, `std::set` | 레드-블랙 트리 | STL 표준 |
| **Python** | `heapq` | 힙 (배열 기반) | 모듈 제공 |


## [부록] 트리를 여행하는 법 (순회, Traversal)

선형 구조(배열)는 그냥 `for`문 돌면 되지만, 트리는 길이 여러 갈래다. 그래서 **방문 순서** 를 정해야 한다.

| 순회 방식 | 순서 | 용도 |
| :--- | :--- | :--- |
| **전위 (Pre-order)** | 나 → 왼쪽 → 오른쪽 | 복사, 직렬화 |
| **중위 (In-order)** | 왼쪽 → 나 → 오른쪽 | BST에서 정렬된 값 출력 |
| **후위 (Post-order)** | 왼쪽 → 오른쪽 → 나 | 폴더 용량 계산 |
| **레벨 (Level-order)** | 1층 → 2층 → ... | BFS, 큐 사용 |


## 관련 문서

* **ADT:** [Map](../../02_ADT/Map.md), [Set](../../02_ADT/Set.md)
* **고급 트리:** [AdvancedTree_Overview](./AdvancedTree_Overview.md)
* **개념서:** [자료구조 개념서](../../00_Core_Concept/자료구조_개념서.md)
