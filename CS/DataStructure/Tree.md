# [자료구조] 트리(Tree)와 힙(Heap) 개념 정리 - 4단계 사고법

## 0. 들어가며
선형 자료구조(스택, 큐, 리스트)는 정복했다.
이제 순서가 없거나, 더 복잡한 규칙이 필요한 **비선형 자료구조** 로 넘어간다.
그 첫 번째 목표는 **'우선순위 큐'** 를 만들기 위한 **'힙(Heap)'** 이다.


## 1단계 : 상황에 필요한 기능 정의 (ADT)
> **"우선순위 큐 (Priority Queue)가 필요해."**

* **상황:** 데이터가 들어온 순서는 중요하지 않다. **'가장 중요한 놈(최댓값/최솟값)'** 이 무조건 먼저 나가야 한다.
* **기능:**
    * `offer()`: 데이터를 넣는다. (순서 상관 X)
    * `poll()`: 젤 쎈 놈(VIP)이 먼저 나온다.


## 2단계 : 핵심 가치 판단
> **"일자(Linear)로 줄 세우는 걸로는 답이 안 나와. 트리(Tree) 쓰자."**

* **판단:**
    * 배열/연결리스트: 중간에 있는 VIP를 찾거나, 새치기 시키려면 데이터를 다 밀어야 해서 비효율적이다.
    * **트리(Tree):** 부모-자식 간의 **계층(상하) 관계** 를 만들어서 대장(Root)을 관리하는 게 낫겠다.


## 3단계 : 기본 설계도
> **"그냥 트리는 너무 복잡해. '이진 트리(Binary Tree)'로 가자."**

* **설계:** 자식을 막 100명씩 낳으면 관리가 안 된다.
* **제약:** 자식은 **최대 2명(왼쪽/오른쪽)** 까지만 낳는 걸 기본 뼈대로 잡는다.


## 3.5단계 : 고오급 설계도 (힙 Heap의 탄생)
> 여기가 핵심이다. 목적에 따라 설계도가 갈린다.

### 분기점 : 목적이 무엇인가?
1.  **검색(Search)**이 목적인가? 👉 **이진 탐색 트리 (BST)**
    * 규칙: `왼쪽 < 나 < 오른쪽` (대소 관계 확실히)
    * 모양: 삐뚤빼뚤해도 됨.
2.  **우선순위(VIP) 추출**이 목적인가? 👉 **힙 (Heap)** **(★우리의 선택)**
    * 규칙 1 (모양): **[완전 이진 트리]** 여야 함. 위->아래, 좌->우 빈틈없이 꽉 채울 것.
    * 규칙 2 (질서): **부모는 자식보다 무조건 세야 함.** (형제끼리는 상관 X)


## 4단계 : 물리적 구현 (Implementation)
> **"어? 힙은 빈틈이 없네? 그럼 '배열(Array)'이 정답이다."**

* **판단:**
    * 보통 트리는 `Node` 객체 만들고 주소 연결하고 복잡하다.
    * 하지만 **힙(Heap)**은 **완전 이진 트리** 라서 중간에 빈 공간이 없다.
    * 굳이 메모리 낭비하며 링크 연결할 필요 없이 **배열(ArrayList)** 에 인덱스 순서대로 때려 박으면 된다.

### [핵심] 배열 인덱스 공식 (1번 인덱스 시작 기준)
배열로 트리를 구현하기 위한 마법의 공식.

```java
1. 내 왼쪽 자식  = index * 2
2. 내 오른쪽 자식 = index * 2 + 1
3. 내 부모님      = index / 2
````

---

### ⚡ 요약 정리

| 개념 | 단계 | 한 줄 요약 |
| :--- | :--- | :--- |
| **우선순위 큐** | 1단계 (ADT) | "VIP 먼저 나가는 줄서기 기능이 필요해." |
| **트리** | 2단계 (구조) | "계층형 구조가 필요해." |
| **이진 트리** | 3단계 (기본설계) | "자식은 둘까지만 낳자." |
| **완전 이진 트리** | 3.5단계 (제약) | "배열에 넣게 빈칸 없이 꽉 채워." (모양 강박) |
| **힙 (Heap)** | 3.5단계 (완성) | **"완전 이진 트리 + 부모가 짱 먹는 규칙"** |
| **ArrayList** | 4단계 (구현체) | "힙은 구멍 없으니까 배열로 구현하자." |