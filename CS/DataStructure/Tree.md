# [자료구조] 트리(Tree)와 파생 개념 완전 정복

우리는 지금까지 선형(Linear) 구조를 배웠다. 하지만 세상의 데이터는 일렬로 서 있지 않다.
**계층(Hierarchy)**이 있거나, **빠른 검색**이 필요한 순간, 우리는 **트리**의 세계로 진입해야 한다.


## 1단계 : 상황에 필요한 기능을 정의한다 (Requirements)
* **상황:** "데이터 간의 **상하 관계(계층)**를 표현해야 해." 또는 "데이터를 **엄청나게 빨리 찾고(Search)** 싶어."
* **기능:**
    * `root`: 대장(시작점)이 존재한다.
    * `parent-child`: 부모와 자식이 연결된다.
    * `search`: 원하는 값을 효율적으로 찾아낸다.

## 2단계 : 핵심 가치 판단 (Core Value & Type)
* **질문:** "왜 배열이나 리스트(선형 구조)로는 안 되는가?"
* **판단:**
    * **선형(List):** 100만 개 데이터에서 하나를 찾으려면 최악의 경우 100만 번 확인해야 한다 ($O(N)$). 너무 느리다.
    * **계층(Tree):** 데이터를 반씩 쪼개서 찾거나(Divide & Conquer), 상하 관계를 만들면 관리가 쉽다.
* **결정:** **비선형 자료구조인 트리(Tree) 타입**을 선택한다.

## 3단계 : 설계도를 짠다 (Logical Design)
* **질문:** "트리를 어떤 규칙으로 만들 것인가?"
* **설계:** 일반 트리는 자식이 N명이라 관리가 복잡하다. **자식을 최대 2명으로 제한**하는 **이진 트리(Binary Tree)**를 기본 뼈대로 잡는다.

### [핵심] 이진 트리의 종류 (모양에 따른 분류)
3단계에서 결정한 모양(Shape)에 따라 4단계 구현 방식과 성능이 갈린다.

1.  **일반 이진 트리:** 그냥 자식이 둘인 트리. (별 특징 없음)
2.  **완전 이진 트리 (Complete Binary Tree):** 위에서 아래로, **왼쪽에서 오른쪽으로 빈틈없이 채운** 트리. (**★ 4단계 배열 구현의 필수 조건**)
3.  **포화 이진 트리 (Perfect Binary Tree):** 피라미드처럼 꽉 찬 트리.
4.  **편향 이진 트리 (Skewed Binary Tree):** 한쪽으로만 쭉 뻗은 트리. (사실상 연결 리스트와 다를 게 없음, 성능 최악)


## 3.5단계 : 고오급 설계도 (Specific Algorithm)
> **"단순 이진 트리에 '특수 목적'을 위한 알고리즘을 입힌다."**
> 여기서 우리가 아는 유명한 자료구조들이 탄생한다.

### A. 목적이 '검색(Search)' 인가?
* **규칙:** **"나보다 작은 건 왼쪽, 큰 건 오른쪽으로 가라."**
* **결과:** **이진 탐색 트리 (Binary Search Tree, BST)**
* **효과:** 데이터를 찾을 때마다 탐색 범위가 절반으로 줄어든다 ($O(\log N)$).

### B. 목적이 '우선순위(VIP) 추출' 인가?
* **규칙 1 (모양):** 무조건 **완전 이진 트리**여야 한다. (배열에 넣기 위해)
* **규칙 2 (질서):** **부모는 자식보다 무조건 커야 한다.** (형제끼린 상관 X)
* **결과:** **힙 (Heap)**
* **효과:** 최댓값(루트)을 1초 만에 뽑을 수 있다 ($O(1)$).


## 4단계 : 물리적 구현 (Physical Implementation)
> **"이 설계도를 메모리에 어떻게 올릴까?"**
> 3단계와 3.5단계에서 결정한 모양에 따라 구현 방법이 나뉜다.

### 방법 1 : 연결 기반 (Linked) - `Node`
* **대상:** 일반 트리, **이진 탐색 트리(BST)**
* **이유:** 데이터가 들어올 때마다 자리를 잡아야 하므로, 유동적인 연결 방식이 유리하다. 빈 구멍이 많아도 상관없다.
* **구조:**
    ```java
    class Node {
        Data value;
        Node left;  // 왼쪽 주소
        Node right; // 오른쪽 주소
    }
    ```

### 방법 2 : 배열 기반 (Array) - `ArrayList`
* **대상:** **힙 (Heap)**
* **이유:** 힙은 **완전 이진 트리(3단계 조건)**이므로 중간에 빈칸이 없다. 인덱스 공식으로 부모-자식을 찾는 게 훨씬 빠르고 메모리도 아낀다.
* **구조:**
    ```java
    // 인덱스 공식 (1번 인덱스 시작 기준)
    Left Child  = Index * 2
    Right Child = Index * 2 + 1
    Parent      = Index / 2
    ```

## 💡 한 눈에 보는 트리 족보

| 단계 | 개념 | 설명 | 대표적인 예 |
| :--- | :--- | :--- | :--- |
| **1 (ADT)** | **계층형 데이터** | "상하 관계가 필요해" | 조직도, 파일 시스템 |
| **2 (Type)** | **트리 (Tree)** | "비선형 구조를 쓰자" | 일반 트리 |
| **3 (Design)** | **이진 트리** | "자식은 둘까지만 낳자" | 이진 트리 |
| **3.5 (Algo)** | **BST** | "왼쪽은 작고, 오른쪽은 크게" | `TreeSet`, `TreeMap` |
| **3.5 (Algo)** | **힙 (Heap)** | "완전 이진 트리 + 부모가 짱" | `PriorityQueue` |
| **4 (Impl)** | **Node / Array** | "링크로 연결하거나, 배열에 담거나" | 구현 코드 |


## [부록] 트리를 여행하는 법 (순회, Traversal)
선형 구조(배열)는 그냥 `for`문 돌면 되지만, 트리는 길이 여러 갈래다. 그래서 **방문 순서**를 정해야 한다.

1.  **전위 순회 (Pre-order):** **나(Root)** -> 왼쪽 -> 오른쪽
2.  **중위 순회 (In-order):** 왼쪽 -> **나(Root)** -> 오른쪽 *(BST에서 쓰면 정렬된 값이 나옴)*
3.  **후위 순회 (Post-order):** 왼쪽 -> 오른쪽 -> **나(Root)** *(폴더 용량 계산할 때 씀)*
4.  **레벨 순회 (Level-order):** 1층부터 층별로 훑기 *(BFS, 큐 사용)*