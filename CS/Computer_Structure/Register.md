## 레지스터란 무엇인가?
0. **핵심으로 레지스터는 대부분 가상 주소를 사용한다.**
    - 커널이나 펌웨어가 사용하는 특수 레지 제외.
1. 기본적으로 CPU 안에 내장되어 있는 저장소이다.
2. CPU 는 대부분 레지스터에 읽고 쓴다.
3. 그렇기 때문에 레지스터에 어떤 값이 들어오고 나가는지만 관찰해도 프로그램의 흐름을 알 수 있다.
4. 이런 레지스터는 여러개가 있으며, 특정 역할만을 하는 레지스터들도 있다. 
5. 이러한 레지스터들도 CPU 아키텍쳐에 따라 이름, 크기, 종류가 다르다. 
6. 하지만 공통으로 포함하는 대표적인 레지스터 7개가 있다. (8 종류는 아래에서 다룬다.)
7. 메모리의 데이터를 캐시하는 공간이기도 하다. 메모리 계층 구조에서 L1 L2 등의 캐시 메모리에 해당한다.
8. DRAM 과 다르게 동적이지 않다. SRAM 정적메모리이며, DRAM 과 다르게 전기 누수가 없고 용량은 훨씬 작지만 속도는 훨씬 빠르고 비싸다.
    - 왜 동적, 정적 메모리라고 불리나? -> 데이터 유지 방식의 차이 때문인데 DRAM은 누수가 있어 refresh 하지 않으면 데이터가 사라지지만 SRAM 은 전원이 켜지면 그대로 유지됨.
    - 말고도 뭐 DRAM은 실제로 전기신호가 오면 스위치처럼 동적으로 움직이는데 SRAM은 전구처럼 딱 불만 들어온다고도 한다.

## 반드시 알아야할 레지스터 7가지
1. 프로그램 카운터 (ProgramCounter : PC)
    - **다음에 가져올** 명령어의 주소를 저장한다.

2. 메모리 주소 레지스터 (Memory Address Register : MAR)
    - **PC에서 가져온 주소값을 저장한다** -> 왜 또 PC 에서 가져온 주소를 저장하냐? 이때 PC 는 바로 다른 주소를 가르키게 되어 효율을 올린다.
    - 파이프라이닝 기법을 사용하는 것인데, 대표적으로 CPU 에서 Fetch - DeCode - Execute 개념에서 나온다
    - 레지스터에서 마지막 IR 까지 도달하는 과정은 Fetch 안에서도 세부적인 단계의 파이프라이닝 기법이다.

3. 메모리 버퍼 레지스터 (Memory Buffer Register : MBR) or (Memory Data Register : MDR)
    - MAR 의 주소값을 통해 해당 **데이터를 저장하는 레지스터**
    - 앞서 PC와 MAR 은 명령어가 담긴 주소를 저장하는 레지스터라면 해당 레지스터는 명령어 값을 저장하는 레지스터이다.
    - 프로그래밍 코드로 표현하면, MBR = Memory[MAR] 이런 느낌으로 주소가 아닌 데이터 자체를 저장한다. 

4. 명령어 레지스터 (Instruction Register : IR)
    - 해석할 명령어로, MBR 에서 전달 받는다. 해당 CPU가 해당 명령어를 해석하고 제어신호를 내보낸다.

5. 플래그 레지스터 (Flag Register : FR)
    - ALU 배웠듯, 연산된 결과값에 부연설명을 해주는 레지스터이다.

6. 범용 레지스터 (General Register : GR)
    - 말 그대로 다양한 상황에서 사용할 수 있는 범용적이며 일반적인 레지스터이다.
    - 데이터와 주소 모두 저장할 수 있다.

7. 스택 포인터 (Stack Pointer : SP)
    - 자료구조 스택의 위치를 알려주는 말그대로 스택포인터이다.
    - 함수 호출 시 복귀 주소를 스택에 저장한다. 
    - 무한 재귀가 발생하면, 이러한 스택레지스터의 용량을 초과하여 스택 오버플로우가 발생한다.
        - 함수 실행 시 스택에 스택프레임 이라는 값이 쌓이고, 함수가 종료 시 해당 스택프레임이 해제된다.
        - 함수 종료가 안되고 계속해서 무한으로 재귀 함수가 호출 되면 해제되는 값 없이 무한으로 스택이 쌓이게 되는 원리이다.

8. ~~베이스 레지스터 (Base Register : BR)~~
    - 각 프로세스 별로 메모리 공간을 가져야 하는데 이를 지키기 위해 각 프로세스 별 시작 주소를 베이스 레지스터에 저장한다.
    - 하지만 오늘날에는 가상 주소와 페이징 기법으로 사라진 레지스터이다.
