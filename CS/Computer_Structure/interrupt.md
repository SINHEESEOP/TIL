# 인터럽트를 알기위한 간략한 명령어 사이클 설명
- 명령어를 처리하는 과정 Fetch cycle - Decode cycle - Indirect cycle - Excute cylce - interrupt cycle 으로 명령어 사이클이 돈다.
    - Indirect cycle 의 경우, 간접 주소 지정 방식등의 의해서 다시 메모리에서 읽는 단계를 말한다.

# 인터럽트란(interrupt) 란?
위와 같은 명령어 사이클이 반복되는 CPU 의 흐름을 끊는 것.  
그렇다면 왜 끊을까? CPU 가 다른 급한 작업을 처리 할 수 있도록 흐름을 끊는 것이다.  
인터럽트는 먼저 크게 두가지로 나눌 수 있다. 
- 동기 인터럽트 (예외)
- 비동기 인터럽트 (하드웨어 인터럽트)

## 하드웨어 인터럽트란?
만약 외부 입출력장치인 스캐너를 사용한다고 가정하고, 해당 스캐너가 스캔한 내용을 화면에 띄우고자 할 때  
해당 내용을 읽기 위해 스캔이 끝날때 까지 대기한다면 엄청난 비효율이 발생한다.
즉, CPU 가 스캔한 데이터를 읽을 수 있다는 알림을 주는 것이 이 하드웨어 인터럽트이다.
이렇게 되면 CPU는 그동안 다른 작업을 처리하다 인터럽트가 발생 할 때만 해당 작업을 처리하면 되는 것이다.  
(마우스나 키보드도 마찬가지이다.)

### 하드웨어 인터럽트의 처리 순서
1. 입출령 장치는 인터럽트 신호를 CPU 에 보냄.
    - 참고 : CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함
2. 인터럽트 요청이 있다면 인터럽트 플래그를 확인하여 처리 가능/불가능을 판단함
3. 플래그레지스터 값이 1이라면 CPU는 지금까지 작업을 백업
4. 인터럽트 백터를 참조하여 인터럽트 서비스 루틴을 실행
5. 끝나면 백업해 둔 작업을 복구하여 재실행

**여기서 인터럽트 플래그가 0이더라도 인터럽트 처리를 해야 하는 상황이 있다.**  
바로 정전이나 하드웨어 고장으로 인한 인터럽트이다.

### 인텁럽트 서비스 루틴(ISR 또는 인터럽트 핸들러)이란?
인터럽트 핸들러라고도 불리며, 인터럽트가 발생했을 때 어떻게 처리하고 작동할지에 대한 정보가 들어있는 **프로그램** 이다.  
각 인터럽트마다 (예: 마우스, 키보드, 스캐너 등) 고유한 ISR 을 가지며, 각 ISR 의 시작 주소는 인터럽트 벡터에 저장된다. 
    - (여기서 벡터는 자료구조 보다는 연속적인 배열의 의미로 쓰인다.)  
    - (왜 시작주소만 저장하냐? -> ISR 도 결국 프로그램이기 때문에 메모리에 어딘가에 저장되어 있어 인터럽트 벡터에는 시작주소만 저장한다.)
또한, 현대의 ISR 은 부팅 시 운영체자가 메모리 상의 인터럽트 디스크립터 테이블(IDT)을 설정하며, 특별한 제약이 없는 경우 고정된 메모리 위치를 할당받아 사용된다. 


각 인터럽트(예: 마우스, 키보드, 스캐너 등)는 **고유한 인터럽트 서비스 루틴(ISR)** 을 가지고 있으며, 이를 구분하기 위해 **인터럽트 벡터(Interrupt Vector)** 를 사용한다.  
**인터럽트 백터**는 각각 ISR의 시작주소를 저장한다. (ISR도 프로그램이니까) 