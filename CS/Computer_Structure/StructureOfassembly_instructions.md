# 명령어는를 이루고 있는 2가지
1. 연산 코드
2. 오퍼랜드
3. 오퍼랜드가 하나도 없으면 0-주소 명령어 라고 하며, 3-주소 명령어까지 있다.  
(4 이상도 있지만 거의 사용X, 이론적 구조에서만 등장) 

## 연산 코드
1. 더해라(add), 이동해라(mov) 등
2. 연산자 라고도 함
3. **연산 코드 필드**라고도 불림

### 연산 코드 종류
1. 연산 코드는 종류는 매우 많지만 크게 4가지로 나뉨
    - 산술/논리 연산 : MOVE, PUSH, POP, STORE, LOAD 등
    - 데이터 전송 : 내가 아는 논리연산 + add, subtract, multiply, divide (+ - * / )
    - 입출력 제어 : READ, WRITE, START IO, TEST IO(입출력장치 상태 확인)
    - 제어 흐름 변경 :  
    JUMP (if 문 느낌, 잘 안쓰이고 다른거 많이 쓰임),   
    CALL (함수 호출등), return (함수 호출했던 곳으로 돌아가라고 ㅇㅇ),   
    HALT (실행 멈춰), conditional jump (조건에 부합 할 때 특정 주소로 실행 순서를 옮겨라)

## 오퍼랜드 
1. 연산에 사용할 데이터 (직접 데이터)
2. 연산에 사용할 데이터가 **저장된 위치** (주소)
3. 피연산자 라고도 함.
4. **오퍼랜드 필드**라고도 불림
5. **주소 필드**라고도 불림

### 주소 필드라고 불리는 이유
- 대부분 연산 데이터가 직접 있기 보다는 해당 데이터가 저장된 주소  
즉, 메모리 주소나 레지스터 이름이 저장되기 때문이다.

```
그렇다면 왜 직접 데이터를 저장하지 않고 주소를 저장할까?
- 저장 할 수 있는 데이터의 크기 때문임.
- 만약, 3-주소 명령어에서 16비트 크기에 4비트 연산코드 사용 시, 각 4비트 사용 가능.  
(4비트면 양의 정수로 16까지 가능)
- 이렇듯 저장 할 수 있는 데이터의 양이 작아서 데이터는 메모리 또는 레지스트에 저장 후  
해당 메모리의 주소 또는 레지스트 이름을 오퍼랜드에 저장함.

## 여기서 실제 저장 된 데이터의 위치(주소)를 유효주소 라고 한다.##
```

### 주소 지정 방식
- 주소 지정 방식은 말 그대로 오퍼랜드(피연산자)를 지정하는 방법이다.  
즉, 명령어가 필요한 데이터를 어디서, 어떻게 가져와 오퍼랜드에 지정하는가를 나타내는 방식.  
교과서에는 흔히 “프로그램 수행 시 오퍼랜드를 지정하는 방법”이라고 정의하며,  
경우에 따라 오퍼랜드를 참조하기 전에 해당 오퍼랜드 값을 해석하거나 변환하는 규칙까지 포함하는 개념으로 설명하기도 함.  
**요약하면 주소 지정 방식은 명령어가 피연산자를 지칭하거나 접근하는 방법 전반을 가리키는 용어입니다.**

- 주소 지정 방시은 크게 5가지가 있다.
1. 즉시 주소 지정 방식
    - 오퍼랜드에 데이터가 직접 박혀있음
2. 직접 주소 지정 방식
    - 오퍼랜드에 요효 주소가 박혀있음
3. 간접 주소 지정 방식
    - 오퍼랜드에 유효 주소가 박혀있는 주소가 박혀있음
4. 레지스터 주소 지정 방식
    - 오퍼랜드에 레지스터이름이 박혀 있음  
    (참고로 레지스터는 주소가 없으며, 정확하게는 레지스터 번호ID 로 CPU가 찾아서 처리함)
5. 레지스터 간접 주소 지정 방식
    - 오퍼랜드에 레지스터이름이 박혀 있음
    - 해당 레지에는 유효주소가 박혀있음
    - 그 유효 주소에 값이 있음.  
    즉, 메모리에 값이 있으며, 그 주소를 레지스터가 저장하고, 그 레지스트ID를 오퍼랜드에 저장.