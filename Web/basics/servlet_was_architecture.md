# 🌐 서블릿의 개념과 역할 (그리고 WAS와의 관계)

아래는 **서블릿(Servlet)**, **서블릿 컨테이너(Servlet Container)**, **톰캣(Tomcat)**, **WAS(Web Application Server)**, 그리고 **NestJS, FastAPI** 등에 대해 각각을 간단히 정리하고, 마지막에 한꺼번에 연결해서 설명한 내용입니다. 이들을 이해하면, 자바와 기타 언어 환경에서 "HTTP 요청을 받아서 애플리케이션 로직을 실행하고 응답을 돌려주는 과정"이 어떻게 구성되는지 한눈에 알 수 있습니다.


## 1. 🧩 서블릿(Servlet): 자바 웹 개발의 핵심 단위

- **정의**: 자바(Java) 언어로 작성된 **서버 측 작은 프로그램**("Server + Applet" 합성어)
- **역할**: HTTP 요청이 들어오면, 서블릿 메서드(`doGet()`, `doPost()` 등)를 통해 **비즈니스 로직을 처리**하고, 결과를 HTTP 응답으로 돌려줌
- **특징**:  
  - 자바 표준 규약(인터페이스)인 `javax.servlet.Servlet`을 구현하거나, `HttpServlet`을 상속받아 작성
  - 서블릿 자체로는 로우 레벨 HTTP 처리 코드가 포함되어 있을 수도 있지만, 실제로는 **컨테이너**가 라이프사이클(생성, 초기화, 소멸)을 관리


## 2. 📦 서블릿 컨테이너(Servlet Container): 서블릿의 운영 환경

- **정의**: **서블릿**을 실행하고 관리(생성, 소멸, 요청 분배 등)하기 위한 **런타임 환경**
- **역할**:
  1. **HTTP 프로토콜**을 통해 들어온 요청을 서블릿 객체로 전달
  2. 서블릿 객체의 `service()`/`doGet()`/`doPost()` 등의 메서드를 호출해 응답을 생성
  3. 서블릿 객체 라이프사이클(init, destroy) 관리
- **예시**: **Tomcat**, **Jetty**, **Undertow** 등이 대표적인 "서블릿 컨테이너"
- **주의**: 자바에서 "WAS(Web Application Server)"라고 부르면 보통 **서블릿 컨테이너** 기능을 포함하고, 더 나아가 트랜잭션, 보안, JPA 등 여러 기능을 제공할 수 있는 서버를 말함


## 3. 🐱 톰캣(Tomcat): 가장 대중적인 서블릿 컨테이너

- **정의**: 대표적인 **서블릿 컨테이너**이자 **WAS**의 한 형태
- **역할**:  
  - HTTP 요청을 받아서 서블릿에 넘겨주고, 서블릿의 실행 결과를 다시 HTTP 응답으로 만들어 클라이언트에게 전송
  - "**Catalina**"라는 엔진이 내부에서 실제 서블릿 컨테이너 로직을 담당
- **특징**:  
  - 과거에는 "Tomcat = 서블릿+JSP를 돌릴 수 있는 가장 간단한 WAS"라는 인식이었고, 자바 웹 개발의 표준처럼 여겨짐
  - 스프링 부트 등에서 "내장 톰캣(Embedded Tomcat)"을 기본적으로 제공해, 서버를 쉽게 띄울 수 있도록 함


## 4. 🏢 WAS(Web Application Server): 서블릿 컨테이너의 확장된 개념

- **정의**: **웹 서버(HTTP 통신) + 애플리케이션 로직(비즈니스 처리) 실행 환경**을 종합적으로 제공하는 서버 소프트웨어
- **역할**:  
  1. 웹 프로토콜(주로 HTTP) 기반 요청을 받아서, 비즈니스 로직(서블릿, EJB, 스프링, JPA 등)을 수행
  2. 데이터베이스 연동, 트랜잭션, 보안, 세션 관리 등 엔터프라이즈 기능을 제공하기도 함
- **예시**:  
  - 가벼운 형태: **Tomcat**, **Jetty** (주로 서블릿 컨테이너 중심)
  - 무거운 형태: **JBoss(WildFly)**, **GlassFish**, **WebSphere**, **WebLogic** (EJB, 더 많은 Java EE 스펙 지원)
- **요약**: 톰캣 같은 서블릿 컨테이너도 WAS 범주에 들어가며, "서블릿/JSP를 돌릴 수 있는 서버"는 모두 WAS 중 하나로 볼 수 있음


## 5. 🔄 다른 언어의 유사 개념들

### 5.1 NestJS(Node.js)  
- Node.js의 **http 모듈** 또는 **Express**/**Fastify**를 기반으로 **HTTP 서버**를 제공
- "서블릿" 같은 자바 표준은 없지만, **컨트롤러**(Controller), **프로바이더**(Service) 등으로 구성한 애플리케이션 로직을 Nest가 관리
- Node 환경에서는 NestJS(혹은 Express/Fastify)가 "요청 → 애플리케이션 코드 → 응답" 흐름을 담당하고, HTTP 처리는 Node.js의 http 모듈이 근간

### 5.2 FastAPI(파이썬)  
- 파이썬에서 비동기 기반(ASGI)으로 **HTTP 요청**을 처리하는 프레임워크
- 웹 서버 레벨에서는 **Uvicorn**(ASGI 서버) 등이 HTTP 소켓을 열어 요청을 받고, FastAPI에게 메서드(엔드포인트)를 호출
- 자바의 "서블릿 컨테이너"와 비슷하게, "**ASGI 서버**"가 실제 HTTP 통신을 담당하고, "**FastAPI**"는 개발자가 작성한 로직(엔드포인트) 실행을 담당

> **결론**: NestJS나 FastAPI는 "서블릿"이라는 용어는 사용하지 않지만, "HTTP 요청을 받아 → 내부 로직 처리 → 응답을 생성"하는 구조는 자바 서블릿과 비슷합니다. 대신 **Node.js/http**, **ASGI** 같은 구현 방식을 사용합니다.


## 6. 🔍 서블릿과 WAS를 통합적으로 이해하기

### 6.1 웹 요청의 처리 흐름
1. **클라이언트(브라우저나 앱)에서 HTTP 요청**을 보냄
2. **서버(톰캣, Jetty, Node.js, Uvicorn 등)**가 소켓을 열고 요청을 받아줌
3. **서블릿 컨테이너**(자바)든, **Express**(Node.js), **FastAPI**(Python)든, 공통적으로 "개발자가 작성한 로직"을 호출해 **비즈니스 처리**를 수행
4. 처리 결과를 **HTTP 응답** 형태로 다시 클라이언트에게 전송

### 6.2 프레임워크별 요청 처리 구조
- **자바 진영**: **서블릿**(개발자 코드) ↔ **서블릿 컨테이너(톰캣 등)** ↔ **클라이언트**  
- **Node 진영**: **컨트롤러/라우트(개발자 코드)** ↔ **Express/Fastify(HTTP 서버)** ↔ **클라이언트**  
- **파이썬 진영**: **엔드포인트(개발자 코드)** ↔ **ASGI 서버(Uvicorn 등)** ↔ **클라이언트**

결국 어떤 언어든, "**웹 서버**가 HTTP 요청을 받아 → **프레임워크**가 개발자 로직을 실행 → **응답**을 돌려주는 패턴"은 똑같고, 자바에서 그 프레임워크와 표준 인터페이스를 "**서블릿**"이라 부르는 것입니다. NestJS나 FastAPI는 각각의 방식으로 같은 역할(요청 처리)을 하는 셈입니다.


## 7. 💡 요약 및 핵심 개념

- **서블릿**: 자바 웹에서 HTTP 처리를 위한 표준 규약, 개발자가 작성하는 코드
- **서블릿 컨테이너**: 서블릿을 실행하고 관리하는 런타임(톰캣, Jetty 등)
- **톰캣**: 서블릿 컨테이너 중 가장 유명한 예시, "WAS"로도 불림
- **WAS**: 웹 요청을 처리하는 애플리케이션 서버 전반(서블릿 컨테이너를 포함), 트랜잭션·보안 등 더 많은 기능을 제공하기도 함
- **NestJS, FastAPI**: 자바가 아닌 Node.js, Python 생태계에서 "HTTP 요청 → 개발자 로직 → 응답"을 처리해주는 대표적 웹 프레임워크 (서블릿이 아니라 각각 Node/http, ASGI 등을 기반으로 동작)

### 7.1 서블릿의 역할 요약
- HTTP 요청 받기 및 파라미터 추출
- 비즈니스 로직 실행하기 (또는 서비스 계층에 위임)
- HTTP 응답 생성하기
- 세션 관리, 쿠키 처리 등의 웹 기능 지원

### 7.2 서블릿 컨테이너의 역할 요약
- 서블릿 인스턴스 생성 및 관리
- 요청에 맞는 서블릿에 작업 분배
- 멀티스레딩 지원
- 보안 및 리소스 관리

## 🎯 결론

언어마다 이름은 다르지만, "웹 요청을 받아서, 개발자 로직을 거쳐, 응답을 돌려주는" 구조는 본질적으로 동일합니다. 자바에선 그 중심에 **서블릿**이라는 표준과, **서블릿 컨테이너**(예: 톰캣)가 있는 것입니다. 서블릿은 자바 웹 개발의 근간이며, 스프링 MVC와 같은 고수준 프레임워크도 내부적으로는 서블릿 API를 기반으로 구축되어 있습니다.

## 8. 🔄 Spring MVC와 Servlet의 관계

아래 내용은 **"과거 서블릿 방식"**과 **"스프링 MVC(DispatcherServlet) 방식"**을 비교하여, 서블릿 아키텍처가 실제로 어떻게 발전했는지, 특히 톰캣, 서블릿, DispatcherServlet, @Controller의 관계를 중심으로 설명합니다.

### 8.1 전통적인 서블릿 개발 방식 (과거)

1. **톰캣(서블릿 컨테이너)**  
   - 80/8080 포트를 열고 HTTP 요청을 받음
   - `web.xml` 등을 통해 매핑된 "서블릿 클래스(HttpServlet 상속)"에 요청을 넘김

2. **개발자가 직접 작성한 서블릿**  
   - 예: `MyServlet extends HttpServlet`  
   - `doGet()`, `doPost()` 안에 비즈니스 로직, DB 접근, HTML 출력(Writer) 작성
   - 사실상 **컨트롤러 역할 + 서비스 역할**을 서블릿 하나가 다 수행

#### 정리
- **톰캣**: 네트워크·HTTP 처리 + 서블릿 라이프사이클(생성, 소멸, 호출) 담당
- **서블릿**: 직접 자바 코드를 통해 **HTTP 요청**을 처리하고, **응답**을 생성

### 8.2 현대적인 Spring MVC 개발 방식 (현재)

1. **톰캣(서블릿 컨테이너)**  
   - 여전히 8080 포트에서 HTTP 요청 수신
   - "**DispatcherServlet**"이라는 서블릿을 "/" 패턴에 매핑

2. **DispatcherServlet** (스프링이 제공하는 프론트 컨트롤러)  
   - 실제 코드 상으로 `HttpServlet`을 상속함 → **서블릿 규약 준수**
   - 요청이 들어오면, 내부적으로 "HandlerMapping, HandlerAdapter, ViewResolver" 등을 통해 "어떤 @Controller 메서드가 이 요청을 처리할지" 찾음
   - 그 컨트롤러 메서드를 실행해, 응답 결과를 만들고 톰캣에 전달

3. **개발자가 작성한 @Controller 클래스**  
   - "**서블릿**을 직접 작성하지 않아도" 스프링이 어노테이션 기반으로 매핑해 줌
   - 예: `@GetMapping("/hello") public String hello() { ... }`
   - 내부적으로는 DispatcherServlet이 이 메서드를 호출

#### 정리
- **톰캣**: 여전히 "HTTP 소켓/포트" + "서블릿" 관리
- **DispatcherServlet**: "**내부적으로 서블릿을 상속**"한 **스프링 전용 서블릿**
- **개발자**: "@Controller" 방식으로 URL 매핑과 로직만 작성 → DispatcherServlet이 받아서 실행

### 8.3 자주 헷갈리는 질문 정리

> **질문**: "결국 오늘날 스프링에선 **서블릿 역할** 누가 하지?"  
> **답**: **"DispatcherServlet"**. 스프링이 제공하는 **서블릿**이 자동 등록되어, 과거처럼 `HttpServlet` 상속을 직접 구현할 필요가 없음.

> **질문**: "HTTP 프로토콜로 응답은 톰캣이 해주는 건가?"  
> **답**: 네. 옛날 서블릿 때와 동일하게, **톰캣**(서블릿 컨테이너)이 최종적으로 응답을 클라이언트에게 전송. DispatcherServlet은 자바 내부에서 로직을 처리하고, `HttpServletResponse`로 결과를 톰캣에 반환. 톰캣이 그것을 HTTP 형식으로 클라이언트에게 전송.

> **질문**: "그럼 개발자는 @Controller만 쓰면 끝?"  
> **답**: 맞습니다. "DispatcherServlet + 스프링 컨테이너"가 자동으로 URL과 @Controller 메서드를 연결해주고, HTTP Request/Response 처리를 자동화.

### 8.4 서블릿과 Spring MVC 흐름 요약

```
┌─────────────────────────────────┐
│        클라이언트 (브라우저)        │
└───────────────┬─────────────────┘
                │ HTTP 요청
                ▼
┌─────────────────────────────────┐
│     톰캣 (서블릿 컨테이너)          │
│                                 │
│  ┌─────────────────────────┐    │
│  │    DispatcherServlet    │    │
│  │    (프론트 컨트롤러)      │    │
│  └───────────┬─────────────┘    │
└───────────────┬─────────────────┘
                │ 요청 분배
                ▼
┌─────────────────────────────────┐
│      스프링 애플리케이션 컨텍스트     │
│                                 │
│  ┌─────────────────────────┐    │
│  │    @Controller 메서드    │    │
│  └───────────┬─────────────┘    │
│              │                  │
│  ┌─────────────────────────┐    │
│  │      @Service 등        │    │
│  └───────────┬─────────────┘    │
└───────────────┬─────────────────┘
                │ 응답 생성
                ▼
┌─────────────────────────────────┐
│        클라이언트 (브라우저)        │
└─────────────────────────────────┘
```

1. **요청 흐름**: 톰캣(서블릿 컨테이너) → DispatcherServlet(서블릿) → @Controller 메서드
2. **발전 과정**: 스프링 MVC 등장 전에는 **직접 서블릿**(`HttpServlet`)을 만들어서 모든 로직을 처리했지만, **지금은 DispatcherServlet이 서블릿 기반 로직을 대신** 하고, 개발자는 @Controller/@GetMapping 등 편의 어노테이션에 집중
3. **HTTP 처리**: **HTTP 통신과 응답**은 예전 서블릿 방식과 마찬가지로 **톰캣**이 최종적으로 관리하며, 스프링의 DispatcherServlet은 "서블릿 규약"을 상속받아 "프론트 컨트롤러" 역할을 수행

### 8.5 Spring Boot에서의 서블릿 구조

Spring Boot를 사용하면 이 구조가 더욱 간소화됩니다:

1. **내장 톰캣(Embedded Tomcat)**: 별도의 톰캣 설치 불필요
2. **자동 설정**: DispatcherServlet 자동 등록 및 설정
3. **어노테이션 기반 개발**: `@SpringBootApplication`, `@RestController` 등으로 더 간편한 개발

결과적으로 서블릿 API는 여전히, 그리고 앞으로도 Java 웹 개발의 근간이지만, 개발자는 Spring의 추상화 계층을 통해 더 높은 수준에서 웹 애플리케이션을 개발할 수 있게 되었습니다.
